[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About (Murali K)",
    "section": "",
    "text": "Welcome to my personal blog! I’m passionate about technology, coding, and sharing knowledge with the community.\n\nWhat I Do\nI work on various projects involving web development, data analysis, and software engineering. This blog serves as a platform where I share insights, tutorials, and thoughts about the technologies I work with.\n\n\nGet in Touch\nFeel free to connect with me on social media or reach out if you’d like to collaborate on projects or discuss technology topics.\nThanks for visiting!"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Template Rendering with Dynamic context",
    "section": "",
    "text": "In one of projects when we had to build a service to generate history for a particular entity if there are changes occurs. we had to build a template engine which can translate the entity changes in humar redable format.\nFormatting text as YAML:\nentity: Event\n    - changes: \n        from: 2020-08-15\n        to: 2020-08-17\n- expected_format: \"Event rescheduled event from Aug 15th to Augh 17th by bob (Current User)\"\nSolution:\nWe have utilized the concept of Binding class able to encapsulate execution context of the receiver object.\nFor simplicity we chose ERB, we can place them within locale files for internationalisation and can be edit them with ease if need arises.\nSince we extend OpenStruct we can simply pass a hash to it during instantiation and all the keys will be accessible as methods and will be exposed directly during rendering.\nrequire 'erb'\nrequire 'ostruct'\n\ninclude ERB::Util\n\nmodule AuditMessage\n  class ErbTemplate &lt; OpenStruct\n    def render(template)\n      ERB.new(template).result(binding)\n    end\n\n    def current_user\n      # ===&gt; Fetch current user\n      user_id, user_type = self[:_audit].user_id, self[:_audit].user_type\n      user_type.classify.constantize.find(user_id)\n    rescue\n      self[:user]\n    end\n\n    def system_user\n      OpenStruct.new(name: \"System User\")\n    end\n\n    def get_old_value(field)\n      # ===&gt; Try to fetch the old value from the audit \n      #  {\"field\": [\"old_value\", \"new_value\"]}\n      get_value(self[field])\n    end\n\n    def get_new_value(field)\n      # ===&gt; Try to fetch the old value from the audit \n      #  {\"field\": [\"old_value\", \"new_value\"]}\n      get_value(self[field], \"new_value\")\n    end\n\n    def method_missing(method, *args, &block)\n      respond_to?(method) ? self[method] : self[:_auditable].send(method, *args)\n    end\n\n    private\n\n    def get_value(value, default_data=\"old_value\")\n      return if value.nil?\n      return send(value) unless value.is_a?(Array)\n      return default_data == \"old_value\" ? value.first : value.last\n    end\n  end\nend\nIn the above example we have used ERB templating engine for parsing the text that we wanted with binding of current context.\nWe added extra methods like current_user who has changed the entity. This particular methods can be available through the context which can be used for back trace or additional info to be passed.\nentity:\n    event: \n        update:\n            message: &gt;-\n            &lt;%= Event rescheduled event from #{format(old_value)} to #{format(old_value)} by #{current_user.name}\" (Current User) %&gt;\nIf we try to this particular example engine will look for the enity event and update action and generate custom message with the template passed to the parser. It tries to find the methods in the context of the current entity if there are any.\nThe benefit of creating a separate abstraction is that it creates a sandbox environment for the template processing. This allows us to have more control over what gets exposed during processing and prevents accidental leakages into the context.\nThe main method here is the render method, where we utilise the ERB library. We create an ERB instance with the supplied template string and then call result, to which we supply the current execution context using the current binding.\nThe usage would look something like this :\nclass Event\n    attr_accessor :event_date\nend\nvars = { \n    old_value: \"2020-08-15\", \n    new_value: \"2020-08-17\"\n }\ntemplate_string = \"entity.#{klass_name}.#{_action}.message\"\n\nAuditMessage::ErbTemplate.new(vars).render(template_string)\n#===&gt; result: \"Event rescheduled event from Aug 15th to Augh 17th by bob (Current User)\""
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hi, I’m Murali",
    "section": "",
    "text": "Top Engineering Blogs from Tech Companies to Follow\n\n\n\ntech\n\n\n\nTop Engineering Blogs from Tech Companies to Follow\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTemplate Rendering with Dynamic Context\n\n\n\nruby\n\nerb\n\nyml\n\ntemplating\n\nrails\n\nROR\n\n\n\nParse the erb template string and make use of binding to encapsulate the current context for parsing.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRails with postgresql views by leveraging active record entity models\n\n\n\npostgres\n\nrails\n\nviews\n\n\n\nRails + postgresql views/materialized views with versioning and usages\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSetup Multiple MySql’s with homebrew in Mac local machine\n\n\n\nmysql\n\ndatabase\n\n\n\nInstall multiple versions of MySql in mac and switch back nd forth if required.\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html#about-me",
    "href": "about.html#about-me",
    "title": "Murali K",
    "section": "",
    "text": "Welcome to my personal blog! I’m passionate about technology, coding, and sharing knowledge with the community.\n\n\nI work on various projects involving web development, data analysis, and software engineering. This blog serves as a platform where I share insights, tutorials, and thoughts about the technologies I work with.\n\n\n\nFeel free to connect with me on social media or reach out if you’d like to collaborate on projects or discuss technology topics.\nThanks for visiting!"
  },
  {
    "objectID": "posts/post-with-code/index.html#problem-statement",
    "href": "posts/post-with-code/index.html#problem-statement",
    "title": "Template Rendering with Dynamic context",
    "section": "",
    "text": "In one of projects when we had to build a service to generate history for a particular entity if there are changes occurs. we had to build a template engine which can translate the entity changes in humar redable format.\nFormatting text as YAML:\nentity: Event\n    - changes: \n        from: 2020-08-15\n        to: 2020-08-17\n- expected_format: \"Event rescheduled event from Aug 15th to Augh 17th by bob (Current User)\"\nSolution:\nWe have utilized the concept of Binding class able to encapsulate execution context of the receiver object.\nFor simplicity we chose ERB, we can place them within locale files for internationalisation and can be edit them with ease if need arises.\nSince we extend OpenStruct we can simply pass a hash to it during instantiation and all the keys will be accessible as methods and will be exposed directly during rendering.\nrequire 'erb'\nrequire 'ostruct'\n\ninclude ERB::Util\n\nmodule AuditMessage\n  class ErbTemplate &lt; OpenStruct\n    def render(template)\n      ERB.new(template).result(binding)\n    end\n\n    def current_user\n      # ===&gt; Fetch current user\n      user_id, user_type = self[:_audit].user_id, self[:_audit].user_type\n      user_type.classify.constantize.find(user_id)\n    rescue\n      self[:user]\n    end\n\n    def system_user\n      OpenStruct.new(name: \"System User\")\n    end\n\n    def get_old_value(field)\n      # ===&gt; Try to fetch the old value from the audit \n      #  {\"field\": [\"old_value\", \"new_value\"]}\n      get_value(self[field])\n    end\n\n    def get_new_value(field)\n      # ===&gt; Try to fetch the old value from the audit \n      #  {\"field\": [\"old_value\", \"new_value\"]}\n      get_value(self[field], \"new_value\")\n    end\n\n    def method_missing(method, *args, &block)\n      respond_to?(method) ? self[method] : self[:_auditable].send(method, *args)\n    end\n\n    private\n\n    def get_value(value, default_data=\"old_value\")\n      return if value.nil?\n      return send(value) unless value.is_a?(Array)\n      return default_data == \"old_value\" ? value.first : value.last\n    end\n  end\nend\nIn the above example we have used ERB templating engine for parsing the text that we wanted with binding of current context.\nWe added extra methods like current_user who has changed the entity. This particular methods can be available through the context which can be used for back trace or additional info to be passed.\nentity:\n    event: \n        update:\n            message: &gt;-\n            &lt;%= Event rescheduled event from #{format(old_value)} to #{format(old_value)} by #{current_user.name}\" (Current User) %&gt;\nIf we try to this particular example engine will look for the enity event and update action and generate custom message with the template passed to the parser. It tries to find the methods in the context of the current entity if there are any.\nThe benefit of creating a separate abstraction is that it creates a sandbox environment for the template processing. This allows us to have more control over what gets exposed during processing and prevents accidental leakages into the context.\nThe main method here is the render method, where we utilise the ERB library. We create an ERB instance with the supplied template string and then call result, to which we supply the current execution context using the current binding.\nThe usage would look something like this :\nclass Event\n    attr_accessor :event_date\nend\nvars = { \n    old_value: \"2020-08-15\", \n    new_value: \"2020-08-17\"\n }\ntemplate_string = \"entity.#{klass_name}.#{_action}.message\"\n\nAuditMessage::ErbTemplate.new(vars).render(template_string)\n#===&gt; result: \"Event rescheduled event from Aug 15th to Augh 17th by bob (Current User)\""
  },
  {
    "objectID": "posts/20-08-15-dynamic-context-with-ruby/index.html",
    "href": "posts/20-08-15-dynamic-context-with-ruby/index.html",
    "title": "Template Rendering with Dynamic Context",
    "section": "",
    "text": "In one of projects when we had to build a service to generate history for a particular entity if there are changes occurs. we had to build a template engine which can translate the entity changes in humar redable format.\nFormatting text as YAML:\nentity: Event\n    - changes: \n        from: 2020-08-15\n        to: 2020-08-17\n- expected_format: \"Event rescheduled event from Aug 15th to Augh 17th by bob (Current User)\"\nSolution:\nWe have utilized the concept of Binding class able to encapsulate execution context of the receiver object.\nFor simplicity we chose ERB, we can place them within locale files for internationalisation and can be edit them with ease if need arises.\nSince we extend OpenStruct we can simply pass a hash to it during instantiation and all the keys will be accessible as methods and will be exposed directly during rendering.\nrequire 'erb'\nrequire 'ostruct'\n\ninclude ERB::Util\n\nmodule AuditMessage\n  class ErbTemplate &lt; OpenStruct\n    def render(template)\n      ERB.new(template).result(binding)\n    end\n\n    def current_user\n      # ===&gt; Fetch current user\n      user_id, user_type = self[:_audit].user_id, self[:_audit].user_type\n      user_type.classify.constantize.find(user_id)\n    rescue\n      self[:user]\n    end\n\n    def system_user\n      OpenStruct.new(name: \"System User\")\n    end\n\n    def get_old_value(field)\n      # ===&gt; Try to fetch the old value from the audit \n      #  {\"field\": [\"old_value\", \"new_value\"]}\n      get_value(self[field])\n    end\n\n    def get_new_value(field)\n      # ===&gt; Try to fetch the old value from the audit \n      #  {\"field\": [\"old_value\", \"new_value\"]}\n      get_value(self[field], \"new_value\")\n    end\n\n    def method_missing(method, *args, &block)\n      respond_to?(method) ? self[method] : self[:_auditable].send(method, *args)\n    end\n\n    private\n\n    def get_value(value, default_data=\"old_value\")\n      return if value.nil?\n      return send(value) unless value.is_a?(Array)\n      return default_data == \"old_value\" ? value.first : value.last\n    end\n  end\nend\nIn the above example we have used ERB templating engine for parsing the text that we wanted with binding of current context.\nWe added extra methods like current_user who has changed the entity. This particular methods can be available through the context which can be used for back trace or additional info to be passed.\nentity:\n    event: \n        update:\n            message: &gt;-\n            &lt;%= Event rescheduled event from #{format(old_value)} to #{format(old_value)} by #{current_user.name}\" (Current User) %&gt;\nIf we try to this particular example engine will look for the enity event and update action and generate custom message with the template passed to the parser. It tries to find the methods in the context of the current entity if there are any.\nThe benefit of creating a separate abstraction is that it creates a sandbox environment for the template processing. This allows us to have more control over what gets exposed during processing and prevents accidental leakages into the context.\nThe main method here is the render method, where we utilise the ERB library. We create an ERB instance with the supplied template string and then call result, to which we supply the current execution context using the current binding.\nThe usage would look something like this :\nclass Event\n    attr_accessor :event_date\nend\nvars = { \n    old_value: \"2020-08-15\", \n    new_value: \"2020-08-17\"\n }\ntemplate_string = \"entity.#{klass_name}.#{_action}.message\"\n\nAuditMessage::ErbTemplate.new(vars).render(template_string)\n#===&gt; result: \"Event rescheduled event from Aug 15th to Augh 17th by bob (Current User)\""
  },
  {
    "objectID": "posts/20-08-15-dynamic-context-with-ruby/index.html#problem-statement",
    "href": "posts/20-08-15-dynamic-context-with-ruby/index.html#problem-statement",
    "title": "Template Rendering with Dynamic Context",
    "section": "",
    "text": "In one of projects when we had to build a service to generate history for a particular entity if there are changes occurs. we had to build a template engine which can translate the entity changes in humar redable format.\nFormatting text as YAML:\nentity: Event\n    - changes: \n        from: 2020-08-15\n        to: 2020-08-17\n- expected_format: \"Event rescheduled event from Aug 15th to Augh 17th by bob (Current User)\"\nSolution:\nWe have utilized the concept of Binding class able to encapsulate execution context of the receiver object.\nFor simplicity we chose ERB, we can place them within locale files for internationalisation and can be edit them with ease if need arises.\nSince we extend OpenStruct we can simply pass a hash to it during instantiation and all the keys will be accessible as methods and will be exposed directly during rendering.\nrequire 'erb'\nrequire 'ostruct'\n\ninclude ERB::Util\n\nmodule AuditMessage\n  class ErbTemplate &lt; OpenStruct\n    def render(template)\n      ERB.new(template).result(binding)\n    end\n\n    def current_user\n      # ===&gt; Fetch current user\n      user_id, user_type = self[:_audit].user_id, self[:_audit].user_type\n      user_type.classify.constantize.find(user_id)\n    rescue\n      self[:user]\n    end\n\n    def system_user\n      OpenStruct.new(name: \"System User\")\n    end\n\n    def get_old_value(field)\n      # ===&gt; Try to fetch the old value from the audit \n      #  {\"field\": [\"old_value\", \"new_value\"]}\n      get_value(self[field])\n    end\n\n    def get_new_value(field)\n      # ===&gt; Try to fetch the old value from the audit \n      #  {\"field\": [\"old_value\", \"new_value\"]}\n      get_value(self[field], \"new_value\")\n    end\n\n    def method_missing(method, *args, &block)\n      respond_to?(method) ? self[method] : self[:_auditable].send(method, *args)\n    end\n\n    private\n\n    def get_value(value, default_data=\"old_value\")\n      return if value.nil?\n      return send(value) unless value.is_a?(Array)\n      return default_data == \"old_value\" ? value.first : value.last\n    end\n  end\nend\nIn the above example we have used ERB templating engine for parsing the text that we wanted with binding of current context.\nWe added extra methods like current_user who has changed the entity. This particular methods can be available through the context which can be used for back trace or additional info to be passed.\nentity:\n    event: \n        update:\n            message: &gt;-\n            &lt;%= Event rescheduled event from #{format(old_value)} to #{format(old_value)} by #{current_user.name}\" (Current User) %&gt;\nIf we try to this particular example engine will look for the enity event and update action and generate custom message with the template passed to the parser. It tries to find the methods in the context of the current entity if there are any.\nThe benefit of creating a separate abstraction is that it creates a sandbox environment for the template processing. This allows us to have more control over what gets exposed during processing and prevents accidental leakages into the context.\nThe main method here is the render method, where we utilise the ERB library. We create an ERB instance with the supplied template string and then call result, to which we supply the current execution context using the current binding.\nThe usage would look something like this :\nclass Event\n    attr_accessor :event_date\nend\nvars = { \n    old_value: \"2020-08-15\", \n    new_value: \"2020-08-17\"\n }\ntemplate_string = \"entity.#{klass_name}.#{_action}.message\"\n\nAuditMessage::ErbTemplate.new(vars).render(template_string)\n#===&gt; result: \"Event rescheduled event from Aug 15th to Augh 17th by bob (Current User)\""
  },
  {
    "objectID": "posts/2020-08-17-multiple-mysql-versions.md/index.html",
    "href": "posts/2020-08-17-multiple-mysql-versions.md/index.html",
    "title": "Setup Multiple MySql’s with homebrew in Mac local machine",
    "section": "",
    "text": "Setup Multiple MySql’s with homebrew in Mac local machine\nHad a specific scenario in my projects where two services are using MySql but different versions. So had to switch between different MySql versions on demand.\n\nWill try to support for brew version For homebrew version 0.9.5.\n\n    brew -v # =&gt; Homebrew 0.9.5\n\nInstall the current/latest version of mysql.\n\n    # Install current mysql version\n    brew install mysql\n    \n    # Start agent for current version of mysql (including on login)\n    ln -sfv /usr/local/opt/mysql/*.plist ~/Library/LaunchAgents\n    launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist\n\nInstall the older/Specific version of mysql.\n\n      \n    # Find older mysql versions\n    brew search mysql  \n      \n    # Install older mysql version\n    brew install homebrew/versions/mysql56\n    \n    # Start agent for older version of mysql (including on login)\n    ln -sfv /usr/local/opt/mysql56/*.plist ~/Library/LaunchAgents\n    launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mysql56.plist\n\nThen to switch to the older version.\n\n    # Unlink current mysql version\n    brew unlink mysql \n    \n    # Check older mysql version\n    ls /usr/local/Cellar/mysql56 # =&gt; 5.6.27\n    \n    # Link the older version\n    brew switch mysql56 5.6.27\n\nswitch back to the current version.\n\n    # Unlink older mysql version\n    brew unlink mysql56 \n    \n    # Check current mysql version\n    ls /usr/local/Cellar/mysql # =&gt; 5.7.10\n    \n    # Link the current version\n    brew switch mysql 5.7.10\n\nVerify which mysql version you’re on at any time.\n\n    # Check which version of mysql is currently symlinked\n    ls -l /usr/local/bin/mysql # =&gt; /usr/local/bin/mysql@ -&gt; ../Cellar/mysql56/5.6.27/bin/mysql\n    \n    # Or using the mysql command\n    mysql --version\n\nunload a mysql agent for a given version.\n\n    # Stop agent for current version of mysql\n    launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist\n    rm ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist\n    \n    # Stop agent for older version of mysql\n    launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.mysql56.plist\n    rm ~/Library/LaunchAgents/homebrew.mxcl.mysql56.plist"
  },
  {
    "objectID": "posts/2020-08-20-top-engineering-blogs.md/index.html",
    "href": "posts/2020-08-20-top-engineering-blogs.md/index.html",
    "title": "Top Engineering Blogs from Tech Companies to Follow",
    "section": "",
    "text": "Here is a list of top engineering blogs from tech companies that’s worth following. (in alphabetical order)\n\n Airbnb Engineering & Data Science\n Bitly Engineering Blog\n Dropbox Tech Blog\n Etsy - Code as Craft\n Facebook Code - Facebook Engineering Blog\n code.flickr.com\n GitHub Engineering\n Google AI Blog\n Google Developers\n Heroku Blog - Engineering\n Hulu Tech Blog\n Indeed Engineering Blog\n Instagram Engineering\n LinkedIn Engineering\n Lyft Engineering\n Medium Engineering\n Netflix Techblog\n Paypal Engineering\n Pinterest Engineering\n Reddit Blog\n Robinhood Engineering\n Shopify Engineering Blog\n Slack Engineering Blog\n Spotify’s Engineering and Technology Blog\n Square’s Technical Blog - The Corner\n Squarespace Engineering\n Stripe Engineering\n Twilio Engineering Blog\n Uber Engineering\n Yahoo Engineering\n Yelp Engineering Blog\n YouTube Engineering and Developers Blog\n\nNote: Inspired from tonyxu-io"
  },
  {
    "objectID": "posts/2020-09-15-rails-postgres-views.md/index.html",
    "href": "posts/2020-09-15-rails-postgres-views.md/index.html",
    "title": "Rails with postgresql views by leveraging active record entity models",
    "section": "",
    "text": "We had a use case where we had to generate a report in an existing meeting scheduler system. This report shows all the data of the report around the meeting.\nWhile showing the report it involves the most complex logic based on role, meetings, meeting attendees, meeting customer information, meeting notes that are being captured. There are around 20+ filters present around the reports.\nWe had to expose an endpoint which gives back information in a format of attendee and respective meeting. It could be csv, excel or any other format.\n\n\n\n\nInitially we have decide to implement all reportings in ruby. The naive approach will include initializing each object and associated objects to the meeting.\nThis worked well initially for small amount of data. We have encountered performance issues when there are more than 2K meetings and each meeting has approximately 10. Which eventually become 21K objects initialization and storing the data in-memory while processing all of them.\nBenchmark.bm { |x| x.report {\n  MeetingRequest.all.each do |meeting_request|\n    meeting_request_details = meeting_request.meeting_meta_reports_on_demand(mm_role_uuid, [], ' || ', {template_mode: \"separated\"})\n  end\n} }\n #      user     system      total        real\n #    444.780000  12.660000 457.440000 (780.303877)\n # =&gt; [#&lt;Benchmark::Tms:0x000000001ba8cc88 @label=\"\", @real=780.3038765005767, @cstime=0.0, @cutime=0.0, @stime=12.66, @utime=444.78000000000003, @total=457.44000000000005&gt;]\nIt takes 10 seconds to retrieve the data and to format it. In a real life scenario, we would have to account for the time needed for the request to go through all the stack, from routing to rendering the views. 10 seconds is a lot of time, especially if you have lots of requests coming.\nIt starts taking more than 60 seconds if the request is having heavy data to manipulate and request.\n\n\n\n\n                Database view is named query that provides another way to present data in the database tables. A view is defined based on one or more tables which are known as base tables. When you create a view, you basically create a query and assign it a name, therefore a view is useful for wrapping a commonly used complex query.\n\nPostgres has different types of views which are present. * Logical Views * Materialized views\n\n\n                They evaluate the data in the tables underlying the view definition at the time the view is queried. It is a logical view of your tables, with no data stored anywhere else.\n                The upside of a view is that it will always return the latest data to you. The downside of a view is that its performance depends on how good a select statement the view is based on. If the select statement used by the view joins many tables, or uses joins based on non-indexed columns, the view could perform poorly.\n\n\n\nThey are similar to regular views, in that they are a logical view of your data (based on a select statement), however, the underlying query result set has been saved to a table. The upside of this is that when you query a materialized view, you are querying a table, which may also be indexed. (source)  &gt; Given the fact that we will have a lot of updates at ongoing events and meeting managers expect the reports in real time without any stale data we have decided to go with logical views than materialized views.\n\n\n\n                I have decided to go with (scenic gem)[https://github.com/scenic-views/scenic] considering convention for versioning views that keeps migration history consistent and reversible and avoids having to duplicate SQL strings across migrations\n\nCreating a scenic view\n\n $ rails generate scenic:view meeting\nInitializing plugins...\n      create  db/views/meetings_v01.sql\n      create  db/migrate/20180916125309_create_meetings.rb\n                Meeting View can be used as usal active record model and levarage all the functionalities at the same isolate the SQL queries in migration.\n# Model\nclass MeetingView &lt; ApplicationRecord\n  self.primary_key = :meeting_uuid, :invite_user_uuid\nend\n# [timestamp]_create_meetings.rb\nSELECT\n  meeting_requests.id AS meeting_id,\n  meeting_requests.uuid AS meeting_uuid,\n  meeting_requests.meeting_with as meeting_with,\n  ...\n  ...\n  ...\n  FROM meeting_requests\nLEFT JOIN rooms ON rooms.id = meeting_requests.room_id\nLEFT OUTER JOIN topics ON topics.id = meeting_requests.topic_id\n    ...\n    ...\nLEFT OUTER JOIN requestor ON requestor.uuid = meeting_requests.requestor_uuid\n                We have bench makred same format of the response format and see a major shift in the time that it takes to prepare the data to export. Please check the below report\nBenchmark.bm { |x| x.report {\n  meetings, te, tp, cp, pr = MeetingView.all.sort_and_grouping({}.merge({current_location: location}))\n  settings = MeetingViewUtils::Settings.get_options(meetings, {}.merge({current_location: location}));0\n  meeting_objs = MeetingViewUtils::MergedMeetingViewSerializer.new(meetings, settings, current_event).ondemand_attribs\n} }\n\n#       user     system      total        real\n#    0.220000   0.000000   0.220000 (  3.059728)\n# =&gt; [#&lt;Benchmark::Tms:0x000000002de13138 @label=\"\", @real=3.059727756306529, @cstime=0.0, @cutime=0.0, @stime=0.0, @utime=0.22000000000002728, @total=0.22000000000002728&gt;]\n ##                 We have gone from 780sec to 3secs\n                 As expected, DB Views approach is 260 times faster than the naive ruby approach. If we have proper indexes for tables on what we are querying then it will be way faster. We are in the process of establishing the proper indexes and db scans while writing a scenic view so that it can improve a lot more.\n I’m happy to answer any questions if there are any! HMU in the comments."
  },
  {
    "objectID": "posts/2020-09-15-rails-postgres-views.md/index.html#problem-statement",
    "href": "posts/2020-09-15-rails-postgres-views.md/index.html#problem-statement",
    "title": "Rails with postgresql views by leveraging active record entity models",
    "section": "",
    "text": "We had a use case where we had to generate a report in an existing meeting scheduler system. This report shows all the data of the report around the meeting.\nWhile showing the report it involves the most complex logic based on role, meetings, meeting attendees, meeting customer information, meeting notes that are being captured. There are around 20+ filters present around the reports.\nWe had to expose an endpoint which gives back information in a format of attendee and respective meeting. It could be csv, excel or any other format."
  },
  {
    "objectID": "posts/2020-09-15-rails-postgres-views.md/index.html#initial-implementation-of-reports-in-ruby",
    "href": "posts/2020-09-15-rails-postgres-views.md/index.html#initial-implementation-of-reports-in-ruby",
    "title": "Rails with postgresql views by leveraging active record entity models",
    "section": "",
    "text": "Initially we have decide to implement all reportings in ruby. The naive approach will include initializing each object and associated objects to the meeting.\nThis worked well initially for small amount of data. We have encountered performance issues when there are more than 2K meetings and each meeting has approximately 10. Which eventually become 21K objects initialization and storing the data in-memory while processing all of them.\nBenchmark.bm { |x| x.report {\n  MeetingRequest.all.each do |meeting_request|\n    meeting_request_details = meeting_request.meeting_meta_reports_on_demand(mm_role_uuid, [], ' || ', {template_mode: \"separated\"})\n  end\n} }\n #      user     system      total        real\n #    444.780000  12.660000 457.440000 (780.303877)\n # =&gt; [#&lt;Benchmark::Tms:0x000000001ba8cc88 @label=\"\", @real=780.3038765005767, @cstime=0.0, @cutime=0.0, @stime=12.66, @utime=444.78000000000003, @total=457.44000000000005&gt;]\nIt takes 10 seconds to retrieve the data and to format it. In a real life scenario, we would have to account for the time needed for the request to go through all the stack, from routing to rendering the views. 10 seconds is a lot of time, especially if you have lots of requests coming.\nIt starts taking more than 60 seconds if the request is having heavy data to manipulate and request."
  },
  {
    "objectID": "posts/2020-09-15-rails-postgres-views.md/index.html#working-with-postgres-views",
    "href": "posts/2020-09-15-rails-postgres-views.md/index.html#working-with-postgres-views",
    "title": "Rails with postgresql views by leveraging active record entity models",
    "section": "",
    "text": "Database view is named query that provides another way to present data in the database tables. A view is defined based on one or more tables which are known as base tables. When you create a view, you basically create a query and assign it a name, therefore a view is useful for wrapping a commonly used complex query.\n\nPostgres has different types of views which are present. * Logical Views * Materialized views\n\n\n                They evaluate the data in the tables underlying the view definition at the time the view is queried. It is a logical view of your tables, with no data stored anywhere else.\n                The upside of a view is that it will always return the latest data to you. The downside of a view is that its performance depends on how good a select statement the view is based on. If the select statement used by the view joins many tables, or uses joins based on non-indexed columns, the view could perform poorly.\n\n\n\nThey are similar to regular views, in that they are a logical view of your data (based on a select statement), however, the underlying query result set has been saved to a table. The upside of this is that when you query a materialized view, you are querying a table, which may also be indexed. (source)  &gt; Given the fact that we will have a lot of updates at ongoing events and meeting managers expect the reports in real time without any stale data we have decided to go with logical views than materialized views.\n\n\n\n                I have decided to go with (scenic gem)[https://github.com/scenic-views/scenic] considering convention for versioning views that keeps migration history consistent and reversible and avoids having to duplicate SQL strings across migrations\n\nCreating a scenic view\n\n $ rails generate scenic:view meeting\nInitializing plugins...\n      create  db/views/meetings_v01.sql\n      create  db/migrate/20180916125309_create_meetings.rb\n                Meeting View can be used as usal active record model and levarage all the functionalities at the same isolate the SQL queries in migration.\n# Model\nclass MeetingView &lt; ApplicationRecord\n  self.primary_key = :meeting_uuid, :invite_user_uuid\nend\n# [timestamp]_create_meetings.rb\nSELECT\n  meeting_requests.id AS meeting_id,\n  meeting_requests.uuid AS meeting_uuid,\n  meeting_requests.meeting_with as meeting_with,\n  ...\n  ...\n  ...\n  FROM meeting_requests\nLEFT JOIN rooms ON rooms.id = meeting_requests.room_id\nLEFT OUTER JOIN topics ON topics.id = meeting_requests.topic_id\n    ...\n    ...\nLEFT OUTER JOIN requestor ON requestor.uuid = meeting_requests.requestor_uuid\n                We have bench makred same format of the response format and see a major shift in the time that it takes to prepare the data to export. Please check the below report\nBenchmark.bm { |x| x.report {\n  meetings, te, tp, cp, pr = MeetingView.all.sort_and_grouping({}.merge({current_location: location}))\n  settings = MeetingViewUtils::Settings.get_options(meetings, {}.merge({current_location: location}));0\n  meeting_objs = MeetingViewUtils::MergedMeetingViewSerializer.new(meetings, settings, current_event).ondemand_attribs\n} }\n\n#       user     system      total        real\n#    0.220000   0.000000   0.220000 (  3.059728)\n# =&gt; [#&lt;Benchmark::Tms:0x000000002de13138 @label=\"\", @real=3.059727756306529, @cstime=0.0, @cutime=0.0, @stime=0.0, @utime=0.22000000000002728, @total=0.22000000000002728&gt;]\n ##                 We have gone from 780sec to 3secs\n                 As expected, DB Views approach is 260 times faster than the naive ruby approach. If we have proper indexes for tables on what we are querying then it will be way faster. We are in the process of establishing the proper indexes and db scans while writing a scenic view so that it can improve a lot more.\n I’m happy to answer any questions if there are any! HMU in the comments."
  }
]